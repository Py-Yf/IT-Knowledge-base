## 1. 慢查询
通常来讲，时间复杂度是O(1)的命令是安全的，时间复杂度是O(N)命令在使用时需要注意，避免在使用这些O(N)命令时发生问题主要有几个办法：

* 不要把List当做列表使用，仅当做队列来使用。
* 通过机制严格控制Hash、Set、Sorted Set的大小。
* 可能的话，将排序、并集、交集等操作放在客户端执行。
* 绝对禁止使用KEYS命令。
* 避免一次性遍历集合类型的所有成员，而应使用SCAN类的命令进行分批的，游标式的遍历。

## 2. 网络延迟
* 尽可能使用长连接或连接池，避免频繁创建销毁连接。
* 客户端进行的批量数据操作，应使用管道完成。

## 3. 数据持久化引发的延迟
* AOF + fsync always的设置虽然能够绝对确保数据安全，但每个操作都会触发一次fsync，会对Redis的性能有比较明显的影响。
* AOF + fsync every second是比较好的折中方案，每秒fsync一次。
* AOF + fsync never会提供AOF持久化方案下的最优性能。
* 使用RDB持久化通常会提供比使用AOF更高的性能，但需要注意RDB的策略配置。
* 每一次RDB快照和AOF Rewrite都需要Redis主进程进行fork操作。fork操作本身可能会产生较高的耗时，与CPU和Redis占用的内存大小有关。根据具体的情况合理配置RDB快照和AOF Rewrite时机，避免过于频繁的fork带来的延迟。

## 4. 大对象和大键/键个数和长度的突增
* 尽量只用小的KEY，并且KEY要有可读性，严格控制Value的大小。
## 5. 数据淘汰引发的延迟
* 当同一秒内有大量key过期时，也会引发Redis的延迟。在使用时应尽量将key的失效时间错开。
## 6. 引入读写分离机制
Redis的主从复制能力可以实现一主多从的多节点架构，在这一架构下，主节点接收所有写请求，并将数据同步给多个从节点。在这一基础上，可以让从节点提供对实时性要求不高的读请求服务，以减小主节点的压力。尤其是针对一些使用了长耗时命令的统计类任务，完全可以指定在一个或多个从节点上执行，避免这些长耗时命令影响其他请求的响应。


